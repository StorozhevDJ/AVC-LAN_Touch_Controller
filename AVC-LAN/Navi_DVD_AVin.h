/*
http://www.softservice.com.pl/corolla/avc/avclan.php	//AVC-LAN protocol discription
https://sites.google.com/site/adaptaciaavtomagnitol/spravocnaa/kak-rabotaet-avc-lan	//Описание AVC-LAN
http://catcatcat.d-lan.dp.ua/avc-lan/				//Мультимедийная сеть — AVC-LAN TOYOTA
http://compcar.ru/forum/showthread.php?t=4835		//AVCLan mini project

Прошивка разбита на три части:
 1. Собственно драйвер AVCLan - библиотека AVCLanDrv отвечает за работу с шиной 
  AVCLan и выполняет всю грязную работу за нас.
 2. Скетч AVCLan_mini.pde - основная программа, в которой собираются все части 
  прошивки и описаны все сервисные функции, ее тоже не придется править.
 3. Ну и самая изменяемая часть прошивки - это драйвера устройств. В данном 
  случае CD чейнджера - библиотека AVCLanCDch. Так же есть библиотека AVCLanNavi,
  которая написана на базе прошивки kostya78rus и эмулирует навигацию и чейнджер.

Что умеет текущая прошивка.
1. Автоматическое определение адреса головы. Определяет адрес стабильно, за два 
  месяца работы сбоев не было. Адрес можно задать и вручную.
2. Сервисные функции (для запуска нужно набрать в терминале соответствующую команду)
 P - вывод конфигурации (адрес головы (который определился и который зашит в eeprom), 
  адрес эмулируемого устройства, режим "только чтение", количество переполнений буфера отправки в com-порт
 M - включение / выключение режима "только чтение", т.е. любую прошивку можно 
  превратить в снифер, который будет только слушать шину.
 V - вывод версий компонетнов
 S - начало команды отправляемой в шину (формат совместим с AVCLan-mini)
 W - конец прямой команды, например S002574901903W
 Q - конец широковощательной команды
 H - конец задания адреса головы, например S0110H (S0000H - для автоматического определения адреса головы)
 ? - помощь по командам
 команды для отладки железа
 h - выставляет высокий уровень на шине AVCLan
 l - выставляет низкий уровень на шине
 i - освобождает шину, переходит в режим чтения
 M - отправляет тестовое сообщение в шину (1 360 140 050001121063) 
3. При нормальном приеме в com-порт выводится принятое сообщение, при ошибке строка R#, где #-код ошибки.
4. При ошибке в отправке сообщения, выводится строка W#, где #-код ошибки и   сообщение отправляется повторно. 
  Количество повторов в константе MAXSENDATTEMP в файле config.h, по умолчанию 3 раза.
*/


// адреса eeprom
/*#define E_MASTER1	0  // адрес головы, старший байт
#define E_MASTER2	1  // адрес головы, младший байт
#define E_READONLY	2  // режим "только чтение", если 1, то устройств не регистрируем, только слушаем шину
#define E_INIT		3  // признак инициализации EEPROM*/

#ifdef __cplusplus
extern "C" {
#endif

/*typedef enum
	{
	E_MASTER1=0x20,// адрес головы, старший байт
	E_MASTER2,	// адрес головы, младший байт
	E_READONLY,	// режим "только чтение", если 1, то устройств не регистрируем, только слушаем шину
	E_INIT		// признак инициализации EEPROM
	} TE_ee_map;*/


#define LED_ON		cbi(LED_PORT, LED_OUT);
#define LED_OFF	sbi(LED_PORT, LED_OUT);



void AVCLan_Setup();
void AVCLan_Task();
void terminalTask();


// Чтение конфигурации из EEPROM
void EERPOM_read_config();

void sendMessBROADCAST();//Заготовка для тестовой BROADCAST команды
void sendMessDIRECT();	//Заготовка для тестовой DIRECT команды

#ifdef __cplusplus
}
#endif